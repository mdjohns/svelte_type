{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../TypingTest.svelte",
    "../../DisplayWords.svelte",
    "../../TestForm.svelte",
    "../../Word.svelte"
  ],
  "sourcesContent": [
    "<script>\n  //TODO: If isComplete, display Results\n  import { onMount } from \"svelte\";\n  import { isActive, isComplete } from \"./utils/stores\";\n  import Timer from \"./Timer/Timer.svelte\";\n  import TestForm from \"./Words/TestForm.svelte\";\n  import Header from \"./Header/Header.svelte\";\n\n  //TEST DATA\n  import words from \"./utils/testApiData\";\n\n  let isActive_value;\n  const timerActiveUnsubscribe = isActive.subscribe(\n    (val) => (isActive_value = val)\n  );\n  let isComplete_value;\n  const timerCompleteUnsubscribe = isComplete.subscribe(\n    (val) => (isComplete_value = val)\n  );\n\n  const timeLimit = 90;\n  const numWords = 50;\n  const apiUrl = `https://random-word-api.herokuapp.com/word?number=${numWords}`;\n  //let words = [];\n  let wordObjArr;\n  // onMount(async () => {\n  //   const res = await fetch(apiUrl);\n  //   words = await res.json();\n  // });\n\n  onMount(() => {\n    //TODO: move this to async onMount with fetch\n    wordObjArr = words.map((word) => {\n      return {\n        word: word,\n        isCorrect: null,\n        isActive: false,\n      };\n    });\n    wordObjArr[0].isActive = true;\n  });\n</script>\n\n<style>\n  #test {\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    display: -webkit-box;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: -webkit-flex;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n  }\n</style>\n\n<Header />\n<div id=\"test\">\n  <Timer {timeLimit} />\n  <TestForm words={wordObjArr} />\n\n  <div>Begin typing to start the test!</div>\n\n  <div id=\"help_text\">\n    <p>\n      Press\n      <strong>Enter</strong>\n      to skip the current word.\n    </p>\n  </div>\n</div>\n",
    "<script>\n  import { afterUpdate, beforeUpdate, onMount } from \"svelte\";\n  import Timer from \"../Timer/Timer.svelte\";\n  import { isActive } from \"../utils/stores\";\n  import Word from \"../Words/Word.svelte\";\n\n  export let words = [];\n</script>\n\n<style>\n  #words {\n    width: 12em;\n    height: 10em;\n    overflow: hidden;\n    user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    border: 1px solid black;\n    border-radius: 4px;\n  }\n</style>\n\n<div id=\"words\">\n  {#each words as word}\n    <Word {...word} />\n    <br />\n  {/each}\n</div>\n",
    "<script>\n  import { onMount, afterUpdate } from \"svelte\";\n  import DisplayWords from \"./DisplayWords.svelte\";\n  import { isActive } from \"../utils/stores\";\n\n  export let words;\n  let userInput = \"\";\n  let current = \"\";\n\n  let stats = {\n    numWords: 0,\n    correct: 0,\n  };\n\n  // onMount(() => {\n  //   document.getElementById(\"test_input\").focus();\n  // });\n\n  const startTimer = () => {\n    isActive.update((val) => (val = true));\n  };\n  const handleInput = (e) => {\n    current = words[stats.numWords];\n    console.log(current);\n\n    // Check current progress\n    if (userInput !== current.word.substr(0, userInput.length)) {\n      current.isCorrect = false;\n      words[stats.numWords] = { ...current };\n    }\n    // Reset correct-ness\n    else {\n      current.isCorrect = null;\n      words[stats.numWords] = { ...current };\n    }\n\n    //Submit word on \"space\"\n    if (e.key == \" \") {\n      e.preventDefault();\n      if (userInput === current.word) {\n        current.isCorrect = true;\n        stats.correct++;\n      } else {\n        current.isCorrect = false;\n      }\n      if (stats.numWords !== words.length) {\n        words[stats.numWords + 1].isActive = true;\n        //TODO: handle case where we run out of words before end of timer\n        //maybe check timer length and make additional fetch for more words?\n      }\n      current.isActive = false;\n      words[stats.numWords] = { ...current };\n      stats.numWords++;\n      userInput = \"\";\n    }\n    // Skip word on \"Enter\"\n    else if (e.key == \"Enter\") {\n      e.preventDefault();\n      current.isActive = false;\n      current.isCorrect = false;\n      words[stats.numWords] = { ...current };\n      userInput = \"\";\n      stats.numWords++;\n      if (stats.numWords !== words.length) {\n        words[stats.numWords].isActive = true;\n        //TODO: handle case where we run out of words before end of timer\n      }\n    }\n  };\n</script>\n\n<style>\n  .typing_input {\n    -moz-appearance: textfield;\n    -webkit-appearance: textfield;\n    background-color: white;\n    background-color: -moz-field;\n    border: 1px solid #eee;\n    box-shadow: 1px 1px 1px 0 lightgray inset;\n    font: -moz-field;\n    font: -webkit-small-control;\n    margin-top: 5px;\n    padding: 2px 3px;\n    width: 200px;\n    height: 100%;\n  }\n</style>\n\n<DisplayWords {words} />\n\n<!-- <div>\n  <input\n    type=\"text\"\n    id=\"user_input\"\n    on:keydown|once={startTimer}\n    on:keydown={handleInput}\n    autocomplete=\"false\"\n    data-lpignore=\"true\" />\n</div> -->\n<div\n  class=\"typing_input\"\n  contenteditable=\"true\"\n  on:keydown|once={startTimer}\n  on:keydown={handleInput}\n  bind:innerHTML={userInput} />\n",
    "<script>\n  import { afterUpdate, onMount } from \"svelte\";\n  export let word;\n  export let isCorrect;\n  export let isActive;\n\n  let wordElement;\n  afterUpdate(() => {\n    isActive ? wordElement.scrollIntoView(false) : \"\";\n  });\n</script>\n\n<style>\n  span {\n    color: #000;\n    font-family: serif;\n  }\n  .active {\n    background: #dddddd;\n  }\n  .incorrect-active {\n    background: red;\n    color: white;\n  }\n  .incorrect {\n    color: red;\n  }\n  .correct {\n    color: green;\n  }\n</style>\n\n<span\n  bind:this={wordElement}\n  class:active={isActive}\n  class:incorrect-active={isActive && isCorrect === false}\n  class:incorrect={!isActive && isCorrect === false}\n  class:correct={!isActive && isCorrect === true}>\n  {word}\n</span>\n"
  ],
  "names": [],
  "mappings": "AA4CE,KAAK,cAAC,CAAC,AACL,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,WAAW,CACpB,OAAO,CAAE,QAAQ,CACjB,OAAO,CAAE,WAAW,CACpB,OAAO,CAAE,YAAY,CACrB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AACzB,CAAC;AC9CD,MAAM,cAAC,CAAC,AACN,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,IAAI,CACjB,gBAAgB,CAAE,IAAI,CACtB,mBAAmB,CAAE,IAAI,CACzB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,aAAa,CAAE,GAAG,AACpB,CAAC;ACqDD,aAAa,cAAC,CAAC,AACb,eAAe,CAAE,SAAS,CAC1B,kBAAkB,CAAE,SAAS,CAC7B,gBAAgB,CAAE,KAAK,CACvB,gBAAgB,CAAE,UAAU,CAC5B,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CACzC,IAAI,CAAE,UAAU,CAChB,IAAI,CAAE,qBAAqB,CAC3B,UAAU,CAAE,GAAG,CACf,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,AACd,CAAC;ACxED,IAAI,eAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,KAAK,AACpB,CAAC,AACD,OAAO,eAAC,CAAC,AACP,UAAU,CAAE,OAAO,AACrB,CAAC,AACD,iBAAiB,eAAC,CAAC,AACjB,UAAU,CAAE,GAAG,CACf,KAAK,CAAE,KAAK,AACd,CAAC,AACD,UAAU,eAAC,CAAC,AACV,KAAK,CAAE,GAAG,AACZ,CAAC,AACD,QAAQ,eAAC,CAAC,AACR,KAAK,CAAE,KAAK,AACd,CAAC"
}